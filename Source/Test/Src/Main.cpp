
#include "Tutorial01.h"


int main()
{
	_CSETutorial* pTutorial = new _CSETutorial01();

	pTutorial->Open();
	pTutorial->Init();
	pTutorial->Run();

	return 0;
}


struct SSE_ASSEMBLY
{
	/*
	明确设计：
	1、引用一个对象，需要把它所有子级一起引用，所以变换数据和父子关系保存在装配数据中；一个对象内置子级对象；
	2、对象所有者能够维护更新对象的装配数据，可以把内置对象拆分删除等；
	3、场景设计师在编辑场景时可能会把对象添加为其它对象子级或者追加子级，这时候是把平台装配数据拷贝一份到场景文件中；
	4、协同作业方式，把场景划分为片区，一个片区同时只能由一个人操作，一个人可同时占最多9个片区；
	5、支持两种投影，三种视图：经纬度投影（3D）、球面墨卡托投影（2.5D/2D），采用OGC WMTS标准；
	6、天地图API：http://lbs.tianditu.gov.cn/server/MapService.html
	7、以WMTS开放场景服务，以兼容接入其它系统，支持打包导出；
	8、支持用户自定义瓦片（程序），以处理一下特定的逻辑；一切都以自定义瓦片的形式扩展地图；
	9、标准的WMTS请求中，TILEMATRIX、TILEROW、TILECOL这三个参数代表的就是瓦片的级别、行、列号。
	10、行列号 = FLOOR((原点物理坐标 - 请求物理坐标) / (瓦片像素大小 * 每像素表示物理距离))
	11、球面墨卡托投影：每像素表示物理距离 = 地图比例尺（1厘米的倍数，由用户主观设置） * 英寸转厘米的参数 / 1英寸所包含的像素
	12、瓦片像素大小固定，级别与比例尺相关：比例尺1-1在屏幕上1厘米就表示地图的1厘米
	13、求面坐标，中心点级别由以上方式设定，距离差等于精度差，两倍距离就是两倍精度，垂直向下是最高精度，圆锥辐射精度降低，辐射范围与摄像机高度有关
	14、当摄像机与地表间隔为0时，视野为0，当摄像机与地表间隔为地球半径时，能看见完整地球。但当摄像机不面向球心时不适用，仅用于计算缩放级别
	15、通过摄像机高度换算中心位置比例尺以及当前比例尺范围，下一个范围使用下一个精度，最高精度是1：1
	16、中心精度九宫格，逐环精度递减，每一区块细分等于瓦片像素大小
	17、由于瓦片不能整除，所以首位衔接处有重叠，但由于重叠内容一致，所以不影响效果，先确定最高层级比例尺，在确定最少分割几段

	https://blog.csdn.net/wd4java/article/details/44956799


	
	*/

	/// <summary>
	/// 装配对象坐标。
	/// </summary>
	SSEFloat3 m_mPosition;

	/// <summary>
	/// 装配对象旋转。
	/// </summary>
	SSEFloat3 m_mRotation;

	/// <summary>
	/// 装配对象缩放。
	/// </summary>
	SSEFloat3 m_mScale;


	//9、https://blog.csdn.net/qq_30465893/article/details/78365146
	//10、https ://blog.csdn.net/wd4java/article/details/44956799 https://blog.csdn.net/wd4java/article/details/44956799
	/// 当前句柄（16字节）
	/// 父级句柄
	/// 子级列表句柄（数量/头节点）
	/// 装配数据句柄（装配数据可以被维护人更新，所以他是存储在远程的）（有些父子关系不能变更，即多个装配存在绑定关系）
	
	/// 8个常用组件数据偏移

	/// 查找组件，判断有无组件，从对应位置取到对象

	/// <summary>
	/// 组件数量。
	/// </summary>
	SEUByte m_nComponentCount;

	/// 查找获取某个组件的数据


	// 内存大小（已256为单位）/组件数量（最大255）
	// 唯一句柄

	/// <summary>
	/// 组件组合标记。低24位标记24个标准组件，高8位表示当前绑定其它组件数量。
	/// </summary>
	SEUInt m_nMarks;
};

// 最大255个自定义组件


/*
资源为远程动态加载而非整体打包，所以通过元数据表示数据
引擎也可以基于资源引用下载打包所有资源放到本地
资源之间有相互引用的关系，资源可以更新和删除

句柄
装配文件
资源文件

场景保存所有对象的装配文件，对象的状态变更仅在装配文件中体现。
对象通过资源描述符引用资源

假设一个场景包含1000万个对象，每个对象装配文件1K，场景文件大小10G
对象克隆，组件共享


资源上传到平台后才能使用，在平台上使用其他用户资源免费，但要打包到本地需要付费

两个克隆对象，引用相同的装配文件，并记录有变换的字段，实例化到内存中
如果所有字段都不同，则生成新的装配文件，尽可能避免平台承载太多装配文件
很长时间没有被使用的装配文件将被自动删除

支持多人联机在线编辑

场景类型有地球，开放，动穴，以不同的方式存储装配文件，装配文件动态在内存中装载卸载
不同对象有不同的组件组合，每种组合对应一个线性存储空间
组件数据相同的尽量共享内存
于是对象表示如此组件组合，组件1数据引用，组件2数据引用...
多个同类型的组件，也许他们的数据都一样，只应当占用一个存储空间
大部分数据一样，个别字段不一样


如何避免过多的装配数据
组件组合，各组件数据

很多对象有相同的组件组合
使用UINT位标志表示对象的组件组合
脚本组件被分配一个UINT，用数组存储
比如变换组件的子级列表，子级可能数百上千，如何处理


轻量描述符，独立存储空间
描述符被直接存储在场景数据结构中，如果存在千万个对象，几G的存储空间，则分分成多个文件存储，或者可以随机读写场景数据结构（类似3MX）

对象句柄
对象组件组合
对象数据句柄



*/
