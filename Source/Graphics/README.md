

// 一个默认表面（默认是高效的），多个用户自定义表面（通常用于一些后期特效）
// 创建RenderTarget，绑定RenderTarget，绑定null为默认RenderTarget
// RenderTarget创建后可以重新附着贴图。
// RenderTarget之间可以 共享颜色，深度，模板缓冲区
// https://blog.csdn.net/hi_zhengjian/article/details/48780867
用函数glDrawBuffers来对着色器输出进行路由
//http://docs.gl/es3/glDrawBuffers

GL_PIXEL_UNPACK_BUFFER有两种主要的使用PBO提高传输像素数据的方式：上传到纹理和从帧缓冲区中进行异步回读。
但是WEBGL没有MAP函数，所以上传数据到纹理不会高效


注意如果GPU仍使用此缓冲区对象，glMapBufferARB()不会返回，直到GPU完成了对对应缓冲区对象的操作。为了避免等待，在使用glMapBufferARB之前，使用glBufferDataARB，并传入参数NULL。
然后，OpenGL将废弃旧的缓冲区，为缓冲区分配新的内存。 缓冲区对象必须取消映射,可使用glUnmapBufferARB()。如果成功，glUnmapBufferARB()返回GL_TRUE 否则返回GL_FALSE。
例子:Streaming Texture Uploads
https://blog.csdn.net/dreamcs/article/details/7708018
https://www.cnblogs.com/rainbow70626/p/8719818.html

/// 特殊纹理格式
/// 内部格式 格式（输入的类型） 类型（输入的格式）
/// 不确定大小内部格式有效组合
{GL_LUMINANCE, GL_LUMINANCE, GL_UNSIGNED_BYTE}, // ESE_FORMAT_L8_UINT
{GL_ALPHA, GL_ALPHA, GL_UNSIGNED_BYTE}, // ESE_FORMAT_A8_UINT
{GL_LUMINANCE_ALPHA, GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE}, // ESE_FORMAT_L8A8_UINT

{GL_RGB565, GL_RGB, GL_UNSIGNED_SHORT_5_6_5}, // ESE_FORMAT_R5G6B5_UNORM
{GL_RGB5_A1, GL_RGBA, GL_UNSIGNED_SHORT_5_5_5_1}, // ESE_FORMAT_R5G5B5A1_UNORM
{GL_RGBA4, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4}, // ESE_FORMAT_R4G4B4A4_UNORM
{GL_RGB10_A2, GL_RGBA, GL_UNSIGNED_INT_2_10_10_10_REV}, // ESE_FORMAT_R10G10B10A2_UNORM

{GL_R11F_G11F_B10F, GL_RGB, GL_UNSIGNED_INT_10F_11F_11F_REV}, // ESE_FORMAT_R11G11B10_FLOAT
{GL_RGB9_E5, GL_RGB, GL_UNSIGNED_INT_5_9_9_9_REV}, // ESE_FORMAT_R9G9B9E5_FLOAT

{GL_SRGB8, GL_RGB, GL_UNSIGNED_BYTE}, // ESE_FORMAT_SR8G8B8_FLOAT
{GL_SRGB8_ALPHA8, GL_RGBA, GL_UNSIGNED_BYTE}, // ESE_FORMAT_SR8G8B8A8_FLOAT

{GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT, GL_UNSIGNED_SHORT}, // ESE_FORMAT_D16_FLOAT
{GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT, GL_UNSIGNED_INT}, // ESE_FORMAT_D24_FLOAT
{GL_DEPTH_COMPONENT32F, GL_DEPTH_COMPONENT, GL_FLOAT}, // ESE_FORMAT_D32_FLOAT
{GL_DEPTH24_STENCIL8, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8}, // ESE_FORMAT_D24_UNORM_S8_UINT

{GL_RGB, GL_RGB, GL_UNSIGNED_BYTE}, // 不支持
{GL_RGB, GL_RGB, GL_UNSIGNED_SHORT_5_6_5}, // 不支持
{GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE}, // 不支持
{GL_RGBA, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4}, // 不支持
{GL_RGBA, GL_RGBA, GL_UNSIGNED_SHORT_5_5_5_1}, // 不支持
			
		
/// 确定大小的内部格式（特殊的）
{GL_RGB565, GL_RGB, GL_UNSIGNED_BYTE}, // 不支持
{GL_RGB5_A1, GL_RGBA, GL_UNSIGNED_BYTE}, // 不支持
{GL_RGBA4, GL_RGBA, GL_UNSIGNED_BYTE}, // 不支持

{GL_RGB10_A2UI, GL_RGBA_INTEGER, GL_UNSIGNED_INT_2_10_10_10_REV}, // 不支持
{GL_R11F_G11F_B10F, GL_RGB, GL_HALF_FLOAT}, // 不支持
{GL_R11F_G11F_B10F, GL_RGB, GL_FLOAT},  // 不支持
{GL_RGB9_E5, GL_RGB, GL_HALF_FLOAT},  // 不支持
{GL_RGB9_E5, GL_RGB, GL_FLOAT},  // 不支持

{GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT, GL_UNSIGNED_INT}, // 不支持
{GL_DEPTH32F_STENCIL8, GL_DEPTH_STENCIL, GL_FLOAT_32_UNSIGNED_INT_24_8_REV}, // 不支持

